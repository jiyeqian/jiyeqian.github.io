<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="zh-CN" lang="zh-CN">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="Jiye Qian" />
    <title>高性能R程序</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <link href="/feed/" rel="alternate" title="Jiye Qian" type="application/atom+xml" />
    <link rel="stylesheet" href="/assets/css/style.css" />
    <link rel="stylesheet" href="/assets/css/pygments/default.css" />
    <link rel="stylesheet" href="/assets/css/pygments/default_inline.css" />
    <link rel="stylesheet" href="/assets/css/coderay.css" />
    <link rel="stylesheet" href="/assets/css/twemoji-awesome.css" />  
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">
    <link href="/assets/css/jquery-ui-1.10.4.custom.min.css" rel="stylesheet" />
    <link href="/assets/css/ggvis.css" rel="stylesheet" />
    <link href="/assets/css/mermaid.css" rel="stylesheet" />
    <link rel="stylesheet" href="/assets/css/markdown-plus.css"/> 
    <link rel="stylesheet" href="/assets/css/flexslider.css" type="text/css" media="screen" />
      <style type="text/css">
        .flex-caption {
          width: 96%;
          padding: 2%;
          left: 0;
          bottom: 0;
          background: rgba(0,0,0,.5);
          color: #fff;
          text-shadow: 0 -1px 0 rgba(0,0,0,.3);
          font-size: 14px;
          line-height: 18px;
        }
        li.css a {
          border-radius: 0;
        }
      </style>

    <script type="text/javascript" src="/assets/js/jquery.min.js"></script>
    <script type="text/javascript" src="/assets/js/jquery-ui-1.10.4.custom.min.js"></script>
    <script type="text/javascript" src="/assets/js/d3.min.js"></script>
    <script type="text/javascript" src="/assets/js/vega.min.js"></script>
    <script type="text/javascript" src="/assets/js/lodash.min.js"></script>
    <script>var lodash = _.noConflict();</script>
    <script type="text/javascript" src="/assets/js/ggvis.js"></script>
    <script type="text/javascript" src="/assets/js/htmlwidgets.js"></script>
    <script type="text/javascript" src="/assets/js/echarts-all.js"></script>
    <script type="text/javascript" src="/assets/js/echarts.js"></script>
    <script defer src="/assets/js/jquery.flexslider-min.js"></script>
    <script type="text/javascript">
      // $(function(){
      //   SyntaxHighlighter.all();
      // });
      $(window).load(function(){
        $('.flexslider').flexslider({
          animation: "slide",
          start: function(slider){
            $('body').removeClass('loading');
          }
        });
      });
    </script>

    <script type="text/javascript">
      function setTimeSpan(){
        var date = new Date();
        timeSpan.innerText=date.format('yyyy-MM-dd hh:mm:ss');
      }

      Date.prototype.format = function(format)
      {
        var o =
        {
          "M+" : this.getMonth()+1, //month
          "d+" : this.getDate(),    //day
          "h+" : this.getHours(),   //hour
          "m+" : this.getMinutes(), //minute
          "s+" : this.getSeconds(), //second
          "q+" : Math.floor((this.getMonth()+3)/3),  //quarter
          "S" : this.getMilliseconds() //millisecond
        }
        if(/(y+)/.test(format))
          format=format.replace(RegExp.$1,(this.getFullYear()+"").substr(4 - RegExp.$1.length));
        for(var k in o)
          if(new RegExp("("+ k +")").test(format))
            format = format.replace(RegExp.$1,RegExp.$1.length==1 ? o[k] : ("00"+ o[k]).substr((""+ o[k]).length));
          return format;
        }
      </script>

    <!-- MathJax for LaTeX -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        "HTML-CSS": { extensions: ["handle-floats.js"] },
        TeX: { equationNumbers: { autoNumber: "AMS" } },
        tex2jax: {
            inlineMath: [['$$$', '$$$'], ['$', '$'], ['\\(', '\\)']],
            processEscapes: true
        }
    });
    </script>
    <!-- <script type="text/javascript" src="/assets/js/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  
  <!-- <script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F0b514f17fd99b9fb4be74c94bdd2b7db' type='text/javascript'%3E%3C/script%3E"));
</script>
 -->
  </head>
<!--  <body>
-->

  <body onLoad="setInterval(setTimeSpan,1000);">
    <div id="container">
      <div id="main" role="main">
        <header>
        <h1>高性能R程序</h1>
        </header>
        <nav id="real_nav">
        
          <span><a title="Home" href="/">Home</a></span>
        
          <span><a title="Categories" href="/categories/">Categories</a></span>
        
          <span><a title="Tags" href="/tags/">Tags</a></span>
        
          <span><a title="About" href="/about/">About</a></span>
        
          <span><a title="Search" href="/search/">Search</a></span>
        
        </nav>
        <article class="content">
        <script type="text/javascript" src="/assets/js/outliner.js"></script>

<section class="meta">
<span class="time">
  <time datetime="2015-04-28">2015-04-28</time>
</span>

 |
<span class="categories">
  <i class="fa fa-share-alt"></i>
  
  <a href="/categories/#振导社会" title="振导社会">振导社会</a>&nbsp;
  
</span>


 |
<span class="tags">
  <i class="fa fa-tags"></i>
  
  <a href="/tags/#程序设计" title="程序设计">程序设计</a>&nbsp;
  
  <a href="/tags/#高性能计算" title="高性能计算">高性能计算</a>&nbsp;
  
  <a href="/tags/#R" title="R">R</a>&nbsp;
  
</span>

</section>
<section class="post">
<h2 id="程序性能剖析">程序性能剖析</h2>

<h3 id="确定程序运行时间">确定程序运行时间</h3>

<p>利用<code>system.time</code>：</p>

<div class="highlight"><pre><code class="language-r"><span class="kp">system.time</span><span class="p">(</span><span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span><span class="m">50</span><span class="p">)</span> mad<span class="p">(</span>stats<span class="o">::</span>runif<span class="p">(</span><span class="m">500</span><span class="p">)))</span></code></pre></div>

<p>利用<code>proc.time</code>：</p>

<div class="highlight"><pre><code class="language-r">ptm <span class="o">&lt;-</span> <span class="kp">proc.time</span><span class="p">()</span>
<span class="kr">for</span> <span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span><span class="m">50</span><span class="p">)</span> mad<span class="p">(</span>stats<span class="o">::</span>runif<span class="p">(</span><span class="m">500</span><span class="p">))</span>
<span class="kp">proc.time</span><span class="p">()</span> <span class="o">-</span> ptm</code></pre></div>

<h3 id="性能监控的函数rprof">性能监控的函数Rprof<sup id="fnref:r-perform-rprof-profr"><a href="#fn:r-perform-rprof-profr" class="footnote">1</a></sup></h3>

<h3 id="可视化性能监控lineprof">可视化性能监控lineprof<sup id="fnref:r-perform-lineprof"><a href="#fn:r-perform-lineprof" class="footnote">2</a></sup></h3>

<h2 id="openblas加速矩阵运算">OpenBLAS：加速矩阵运算<sup id="fnref:open-blas-r"><a href="#fn:open-blas-r" class="footnote">3</a></sup></h2>

<p>直接通过<code>brew</code>安装支持OpenBLAS的r：</p>

<div class="highlight"><pre><code class="language-bash">$ brew install openblas --build-from-source
$ brew install r --with-openblas

<span class="c1"># 安装可能遇到的问题：</span>
<span class="c1"># curl: (7) Failed to connect to rcompletion.googlecode.com port 443: Operation timed out</span>
<span class="c1"># Error: Failed to download resource &quot;r--completion&quot;</span>
<span class="c1"># Download failed: https://rcompletion.googlecode.com/svn-history/r31/trunk/bash_completion/R</span></code></pre></div>

<p>也可以直接下载<a href="https://mran.revolutionanalytics.com/download/">Revolution R Open (RRO)</a>，默认就支持OpenBLAS。</p>

<p>如果程序已经是多线程，可能会和OpenBLAS发生冲突，可以在环境变量中设置OpenBLAS为单线程：</p>

<div class="highlight"><pre><code class="language-bash"><span class="nb">export</span> <span class="nv">OPENBLAS_NUM_THREADS</span><span class="o">=</span><span class="m">1</span></code></pre></div>

<p>OpenBLAS提升效果：</p>

<div class="highlight"><pre><code class="language-r"><span class="c1">## 使用了OpenBLAS：</span>
x <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="m">6000</span> <span class="o">*</span> <span class="m">6000</span><span class="p">),</span> <span class="m">6000</span><span class="p">,</span> <span class="m">6000</span><span class="p">)</span>
<span class="kp">system.time</span><span class="p">(</span>tmp <span class="o">&lt;-</span> x <span class="o">%*%</span> x<span class="p">)</span>
<span class="c1">#   user  system elapsed </span>
<span class="c1"># 13.321   0.323   7.315 </span>

<span class="c1">## 没有使用OpenBLAS：</span>
x <span class="o">&lt;-</span> <span class="kt">matrix</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="p">(</span><span class="m">6000</span> <span class="o">*</span> <span class="m">6000</span><span class="p">),</span> <span class="m">6000</span><span class="p">,</span> <span class="m">6000</span><span class="p">)</span>
<span class="kp">system.time</span><span class="p">(</span>tmp <span class="o">&lt;-</span> x <span class="o">%*%</span> x<span class="p">)</span>
<span class="c1">#    user  system elapsed </span>
<span class="c1"># 206.588   2.216 214.333 </span></code></pre></div>

<h2 id="parallel并行计算包">parallel：并行计算包<sup id="fnref:parallel-computing-r"><a href="#fn:parallel-computing-r" class="footnote">4</a></sup><sup id="fnref:blog_61f013b80101rly8"><a href="#fn:blog_61f013b80101rly8" class="footnote">5</a></sup></h2>

<p>parallel包是从snow包和multicore包合并继承而来，包含了很多非常好用的函数。multicore只能在支持fork的操作系统使用，只能用于单台计算机。snow可以用在Unix系列、Windows或者二者混合的集群上。在单处理器单核上使用multicore和snow没效果。</p>

<p>parallel包可以通过PVM（rpvm包）、MPI（Rmpi包）、NetWorkSpaces（nws包）和raw sockets（如果以上3种都不能使用）平台进行分布计算，支持cluster和多核个人/服务器计算机。原则上，parallel可以通过线程（thread）或轻量级进程（lightweight process）实现并行，但是目前都是依赖于进程（process），实现并行有三种方式：</p>

<ol>
  <li>通过<code>system("Rscript")</code>或类似的方式启动进程。安全机制可能会阻止进程间通过socket通信。按照snow的方式，通过socket监听来自主进程命令的进程池称为节点集群。</li>
  <li>通过fork系统调用。fork出的进程副本会共享主进程的内存页，直到其内容发生改变，因此forking方式速度很快。fork的方式最早被multicore采用。由于进程的共享机制，也会共享GUI元素，这回导致havoc<sup id="fnref:havoc"><a href="#fn:havoc" class="footnote">6</a></sup>。进程间可以通过管道和socket方式通信。</li>
  <li>通过系统级机制向其它成员分发任务。snow包利用Rmpi包使用MPI（message passing interface）。这种情况下，通讯过载会增加计算时间，常用于高速内连的网络。在这种工作模式下，CRAN还提供了GridR和Rsge包。</li>
</ol>

<div class="highlight"><pre><code class="language-r">doit <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>x<span class="p">)(</span>x<span class="p">)</span><span class="o">^</span><span class="m">2</span> <span class="o">+</span> <span class="m">2</span><span class="o">*</span>x
<span class="kp">system.time</span><span class="p">(</span>res <span class="o">&lt;-</span> <span class="kp">lapply</span><span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5000000</span><span class="p">,</span>  doit<span class="p">))</span>

 <span class="c1">#   user  system elapsed </span>
 <span class="c1"># 24.624   0.224  25.049 </span>

<span class="kn">library</span><span class="p">(</span>parallel<span class="p">)</span>
cl <span class="o">&lt;-</span> makeCluster<span class="p">(</span><span class="kp">getOption</span><span class="p">(</span><span class="s">&quot;cl.cores&quot;</span><span class="p">,</span> <span class="m">4</span><span class="p">))</span> <span class="c1"># use 4 cores</span>
<span class="kp">system.time</span><span class="p">(</span>res <span class="o">&lt;-</span> parLapply<span class="p">(</span>cl<span class="p">,</span> <span class="m">1</span><span class="o">:</span><span class="m">5000000</span><span class="p">,</span>  doit<span class="p">))</span>
stopCluster<span class="p">(</span>cl<span class="p">)</span> 

  <span class="c1">#  user  system elapsed </span>
  <span class="c1"># 2.405   0.258  10.444 </span>

mc <span class="o">&lt;-</span> <span class="kp">getOption</span><span class="p">(</span><span class="s">&quot;mc.cores&quot;</span><span class="p">,</span> <span class="m">4</span><span class="p">)</span>
<span class="kp">system.time</span><span class="p">(</span>res <span class="o">&lt;-</span> mclapply<span class="p">(</span><span class="m">1</span><span class="o">:</span><span class="m">5000000</span><span class="p">,</span>  doit<span class="p">,</span> mc.cores <span class="o">=</span> mc<span class="p">))</span>

  <span class="c1">#  user  system elapsed </span>
  <span class="c1"># 6.023   1.632   5.300 </span></code></pre></div>

<p><strong>注意：</strong></p>

<ul>
  <li>需要先确定系统处理器核心数目，通常可用<code>detectCores(logical = F)</code>；</li>
  <li>注意函数的调用方式是否为Rscript，该方式会复制对象，内存占用大，处理大数据时要当心。</li>
</ul>

<h2 id="foreach并行计算包1">foreach：并行计算包<a href="#revolution2014doparallel">[1]</a></h2>

<p>foreach包是revolution analytics公司贡献给R开源社区的一个包，它能使R中的并行计算更为方便。</p>

<p>doParallel包是foreach包并行计算的后端，它提供了并行执行foreach循环的机制。foreach必须采用doParallel这样的包才能实现并行计算。用户在使用时必须注册并行计算后端，否则即使用了<code>%dopar%</code>程序也串行执行。doParallel包起着foreach包和parallel包之间接口的作用。默认情况，doParallel包在Unix系列操作系统使用multicore功能，在Windows系统使用snow功能。<a href="#weston2014getting">[2]</a></p>

<div class="highlight"><pre><code class="language-r"><span class="c1"># snow-like</span>
<span class="kn">library</span><span class="p">(</span>doParallel<span class="p">)</span>
cl <span class="o">&lt;-</span> makeCluster<span class="p">(</span><span class="m">2</span><span class="p">)</span>
registerDoParallel<span class="p">(</span>cl<span class="p">)</span>
foreach<span class="p">(</span>i<span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">)</span> <span class="o">%dopar%</span> <span class="kp">sqrt</span><span class="p">(</span>i<span class="p">)</span>

<span class="c1"># multicore-like</span>
<span class="kn">library</span><span class="p">(</span>doParallel<span class="p">)</span>
registerDoParallel<span class="p">(</span>cores<span class="o">=</span><span class="m">2</span><span class="p">)</span>
foreach<span class="p">(</span>i<span class="o">=</span><span class="m">1</span><span class="o">:</span><span class="m">3</span><span class="p">)</span> <span class="o">%dopar%</span> <span class="kp">sqrt</span><span class="p">(</span>i<span class="p">)</span>

<span class="c1">## 该环境的后续程序都按multicore模式进行。</span></code></pre></div>

<p>并行的boostrap：</p>

<div class="highlight"><pre><code class="language-r"><span class="c1">## 已经注册了并行方式，不需要再注册……</span>

x <span class="o">&lt;-</span> iris<span class="p">[</span><span class="kp">which</span><span class="p">(</span>iris<span class="p">[,</span><span class="m">5</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;setosa&quot;</span><span class="p">),</span> <span class="kt">c</span><span class="p">(</span><span class="m">1</span><span class="p">,</span><span class="m">5</span><span class="p">)]</span>
trials <span class="o">&lt;-</span> <span class="m">10000</span>

<span class="c1"># 并行方案</span>
ptime <span class="o">&lt;-</span> <span class="kp">system.time</span><span class="p">({</span>
    r <span class="o">&lt;-</span> foreach<span class="p">(</span>icount<span class="p">(</span>trials<span class="p">),</span> <span class="m">.</span>combine<span class="o">=</span><span class="kp">cbind</span><span class="p">)</span> <span class="o">%dopar%</span> <span class="p">{</span>
      ind <span class="o">&lt;-</span> <span class="kp">sample</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> replace<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
      result1 <span class="o">&lt;-</span> glm<span class="p">(</span>x<span class="p">[</span>ind<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">~</span>x<span class="p">[</span>ind<span class="p">,</span><span class="m">1</span><span class="p">],</span> family<span class="o">=</span>binomial<span class="p">(</span>logit<span class="p">))</span>
      coefficients<span class="p">(</span>result1<span class="p">)</span>
  <span class="p">}</span>
<span class="p">})[</span><span class="m">3</span><span class="p">]</span> 

<span class="c1"># 串行方案：</span>
stime <span class="o">&lt;-</span> <span class="kp">system.time</span><span class="p">({</span>
    r <span class="o">&lt;-</span> foreach<span class="p">(</span>icount<span class="p">(</span>trials<span class="p">),</span> <span class="m">.</span>combine<span class="o">=</span><span class="kp">cbind</span><span class="p">)</span> <span class="o">%do%</span> <span class="p">{</span>
      ind <span class="o">&lt;-</span> <span class="kp">sample</span><span class="p">(</span><span class="m">100</span><span class="p">,</span> <span class="m">100</span><span class="p">,</span> replace<span class="o">=</span><span class="kc">TRUE</span><span class="p">)</span>
      result1 <span class="o">&lt;-</span> glm<span class="p">(</span>x<span class="p">[</span>ind<span class="p">,</span><span class="m">2</span><span class="p">]</span><span class="o">~</span>x<span class="p">[</span>ind<span class="p">,</span><span class="m">1</span><span class="p">],</span> family<span class="o">=</span>binomial<span class="p">(</span>logit<span class="p">))</span>
      coefficients<span class="p">(</span>result1<span class="p">)</span>
  <span class="p">}</span>
<span class="p">})[</span><span class="m">3</span><span class="p">]</span> 

<span class="kt">c</span><span class="p">(</span>ptime<span class="p">,</span> stime<span class="p">)</span>

<span class="c1"># elapsed elapsed </span>
<span class="c1">#  26.372  37.126 </span></code></pre></div>

<h2 id="memoise本地缓存包">memoise：本地缓存包<sup id="fnref:r-cache-memoise"><a href="#fn:r-cache-memoise" class="footnote">7</a></sup></h2>

<p>memoise是一个简单的缓存包，主要用来减少重复计算，从而提升CPU性能。当你用相同的参数执行计算的时候，你会得到之前计算过的结果，而不是重算一遍。缓存技术对于有并发访问的应用来说，是性价比最高的性能提升方案。memoise包只有2个函数：<code>forget</code>重置缓存函数，<code>memoize</code>定义缓存函数。</p>

<div class="highlight"><pre><code class="language-r"><span class="c1">#定义缓存函数</span>
fun <span class="o">&lt;-</span> memoise<span class="p">(</span><span class="kr">function</span><span class="p">(</span>x<span class="p">)</span> <span class="p">{</span> <span class="kp">Sys.sleep</span><span class="p">(</span><span class="m">1</span><span class="p">);</span> runif<span class="p">(</span><span class="m">1</span><span class="p">)</span> <span class="p">})</span>

<span class="c1">#第一次执行fun函数</span>
<span class="kp">system.time</span><span class="p">(</span><span class="kp">print</span><span class="p">(</span>fun<span class="p">()))</span>
<span class="c1"># [1] 0.4342335</span>
<span class="c1">#    user  system elapsed </span>
<span class="c1">#   0.002   0.002   1.004 </span>

<span class="c1">#第二次执行fun函数 </span>
<span class="kp">system.time</span><span class="p">(</span><span class="kp">print</span><span class="p">(</span>fun<span class="p">()))</span>
<span class="c1"># [1] 0.4342335</span>
<span class="c1">#    user  system elapsed </span>
<span class="c1">#   0.001   0.000   0.000 </span>

<span class="c1">#重置缓存函数</span>
forget<span class="p">(</span>fun<span class="p">)</span>

<span class="c1">#第三次执行fun函数 </span>
<span class="kp">system.time</span><span class="p">(</span><span class="kp">print</span><span class="p">(</span>fun<span class="p">()))</span>
<span class="c1"># [1] 0.786522</span>
<span class="c1">#    user  system elapsed </span>
<span class="c1">#   0.003   0.003   1.002 </span></code></pre></div>

<h2 id="compiler编译功能包">compiler：编译功能包<sup id="fnref:speed-up-R"><a href="#fn:speed-up-R" class="footnote">8</a></sup></h2>

<p>执行函数之前，把它编译成二进制程序。</p>

<div class="highlight"><pre><code class="language-r"><span class="kn">library</span><span class="p">(</span>compiler<span class="p">)</span>

myFunction<span class="o">&lt;-</span><span class="kr">function</span><span class="p">()</span> <span class="p">{</span><span class="kr">for</span><span class="p">(</span>i <span class="kr">in</span> <span class="m">1</span><span class="o">:</span><span class="m">1e7</span><span class="p">)</span> <span class="p">{</span><span class="m">1</span><span class="o">*</span><span class="p">(</span><span class="m">1+1</span><span class="p">)}}</span>
myCompiledFunction <span class="o">&lt;-</span> cmpfun<span class="p">(</span>myFunction<span class="p">)</span> <span class="c1"># 编译函数</span>

<span class="kp">system.time</span><span class="p">(</span>myFunction<span class="p">())</span>
  <span class="c1">#  user  system elapsed </span>
  <span class="c1"># 3.448   0.024   3.486 </span>

<span class="kp">system.time</span><span class="p">(</span>myCompiledFunction<span class="p">())</span>
  <span class="c1">#  user  system elapsed </span>
  <span class="c1"># 0.611   0.017   0.637 </span></code></pre></div>

<h2 id="rcppr中融合c3">Rcpp：R中融合C++<a href="#dirk2011rcpp">[3]</a></h2>

<div class="highlight"><pre><code class="language-r"><span class="kn">library</span><span class="p">(</span>Rcpp<span class="p">)</span>

cppFunction<span class="p">(</span>
    <span class="s">&#39;int fib_cpp_0(int n){</span>
<span class="s">       if(n == 1 || n == 2) return 1;</span>
<span class="s">       return(fib_cpp_0(n - 1) + fib_cpp_0( n - 2));</span>
<span class="s">   }&#39;</span>
   <span class="p">)</span>

fib_r <span class="o">&lt;-</span> <span class="kr">function</span><span class="p">(</span>n<span class="p">){</span>
    <span class="kr">if</span><span class="p">(</span>n <span class="o">==</span> <span class="m">1</span> <span class="o">||</span> n <span class="o">==</span> <span class="m">2</span><span class="p">)</span> <span class="kr">return</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
        <span class="kr">return</span><span class="p">(</span>fib_r<span class="p">(</span>n <span class="o">-</span> <span class="m">1</span><span class="p">)</span> <span class="o">+</span> fib_r<span class="p">(</span>n <span class="o">-</span> <span class="m">2</span><span class="p">))</span>
<span class="p">}</span>

<span class="kp">system.time</span><span class="p">(</span>fib_cpp_0<span class="p">(</span><span class="m">30</span><span class="p">))</span>

  <span class="c1">#  user  system elapsed </span>
  <span class="c1"># 0.002   0.000   0.002 </span>

<span class="kp">system.time</span><span class="p">(</span>fib_r<span class="p">(</span><span class="m">30</span><span class="p">))</span>

  <span class="c1">#  user  system elapsed </span>
  <span class="c1"># 1.697   0.021   1.739 </span></code></pre></div>

<p>Rcpp简化了在R中集成C++代码，它将各种R对象映射为特定的C++类，使得C++和R之间的对象管理变得简单、灵活，并提供了对STL等的广泛支持。C++代码可以被编译、链接并动态加载，或者通过包加载。</p>

<p>Rcpp包提供了在C++层次无缝访问、扩展和修改R对象的API。R的API基于<code>SEXP</code>上的函数与宏操作，<code>SEXP</code>是R对象的内部表示。这些API的关键功能包括：C++类对R对象的轻量级封装、自动垃圾回收策略、代码内连、R与C++的数据交换，以及错误处理。</p>

<p>Rcpp包API的两个典型应用场景：</p>

<ol>
  <li>用C++代码替代R代码以提升程序性能；</li>
  <li>方便调用其它库提供的函数。</li>
</ol>

<p>以下代码是采用Rcpp计算卷积：</p>

<div class="highlight"><pre><code class="language-cpp"><span class="cp">#include</span> <span class="cpf">&lt;Rcpp.h&gt;</span><span class="cp"></span>

<span class="n">RcppExport</span> <span class="n">SEXP</span> <span class="nf">convolve3cpp</span><span class="p">(</span><span class="n">SEXP</span> <span class="n">a</span><span class="p">,</span> <span class="n">SEXP</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Rcpp</span><span class="o">::</span><span class="n">NumericVector</span> <span class="n">xa</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="n">Rcpp</span><span class="o">::</span><span class="n">NumericVector</span> <span class="n">xb</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">n_xa</span> <span class="o">=</span> <span class="n">xa</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">n_xb</span> <span class="o">=</span> <span class="n">xb</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">nab</span> <span class="o">=</span> <span class="n">n_xa</span> <span class="o">+</span> <span class="n">n_xb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">Rcpp</span><span class="o">::</span><span class="n">NumericVector</span> <span class="n">xab</span><span class="p">(</span><span class="n">nab</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_xa</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n_xb</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">xab</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">xa</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">xb</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
    <span class="k">return</span> <span class="n">xab</span><span class="p">;</span> 
<span class="p">}</span></code></pre></div>

<p>以上程序展示了使用Rcpp的几个重要方法：</p>

<ul>
  <li>使用Rcpp的API只需要一个头文件Rcpp.h；</li>
  <li><code>RcppExport</code>是方便从C调用C++的宏；</li>
  <li>两个<code>SEXP</code>类型的输入变量，输出变量类型通过R的API的<code>.Call()</code>定义；</li>
  <li>Rcpp将两个输入变量转换成了C++的向量类型；</li>
  <li>通过成员函数<code>size()</code>查看对象大小，通过<code>[]</code>索引向量元素；</li>
  <li>内存管理仍然由R完成；</li>
  <li>返回值自动实现从<code>NumericVector</code>到<code>SEXP</code>的转换。</li>
</ul>

<p>Rcpp sugar能在C++中使用类似R的语法。它不仅提供了漂亮的语法，而且使程序运行更高效。</p>

<h2 id="其它技术">其它技术</h2>

<h3 id="提升读入数据效率">提升读入数据效率</h3>

<p><code>read.table()</code>、<code>read.csv()</code>适合读取小规模数据框，有效地读取大数值矩阵要使用更为底层的<code>read.delim()</code>，甚至<code>scan()</code>函数。<sup id="fnref:r-import-tips"><a href="#fn:r-import-tips" class="footnote">9</a></sup></p>

<p>在读取大型数据时，设定<code>comment.char=""</code>，以读取目标的原子向量类型（逻辑型，整型，数值型，复数型，字符型等）。事先设置好每列的<code>colClasses</code>，给定需要读入的行数<code>nrows</code>（适当地高估一点比不设置这个参数还要快）等措施会部分地提高效率。如果需要试探数据，可以把<code>nrows</code>设置为10或者更小，这样就可以只读取并查看数据的前几行。<sup id="fnref:r-import-tips:1"><a href="#fn:r-import-tips" class="footnote">9</a></sup><sup id="fnref:UtSmVsbMyPb4FQT3"><a href="#fn:UtSmVsbMyPb4FQT3" class="footnote">10</a></sup></p>

<h2 id="参考资料">参考资料</h2>

<ol class="bibliography"><li><span id="revolution2014doparallel">[1]R. Analytics and S. Weston, <i>doParallel: Foreach parallel adaptor for the parallel package</i>. 2014.</span>

[<a href="http://CRAN.R-project.org/package=doParallel">Online</a>]

</li>
<li><span id="weston2014getting">[2]S. Weston and R. Calaway, “Getting Started with doParallel and foreach,” 2014.</span>

</li>
<li><span id="dirk2011rcpp">[3]D. Eddelbuettel and R. François, “Rcpp: Seamless R and C++ Integration,” <i>Journal of Statistical Software</i>, vol. 40, no. 8, pp. 1–18, 2011.</span>

[<a href="http://www.jstatsoft.org/v40/i08/">Online</a>]

</li></ol>

<ul class="bibliography">
  <li><a href="http://cran.r-project.org/web/views/HighPerformanceComputing.html">CRAN Task View: High-Performance and Parallel Computing with R</a></li>
  <li><a href="http://cos.name/2013/12/rcpp-introduction/">Rcpp简明入门</a></li>
  <li><a href="http://adv-r.had.co.nz/Rcpp.html">High performance functions with Rcpp</a></li>
  <li><a href="http://blog.programet.org/2014/02/同时通过openblas和mclapply加速r运算.html">同时通过OpenBLAS和mclapply加速R运算</a></li>
  <li><a href="http://stackoverflow.com/questions/1727772/quickly-reading-very-large-tables-as-dataframes-in-r">Quickly reading very large tables as dataframes in R</a></li>
  <li><a href="http://blog.programet.org/2013/08/给r代码加速.html">给R代码加速</a></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:r-perform-rprof-profr">
      <p><a href="http://blog.fens.me/r-perform-rprof-profr/">R语言性能监控工具Rprof</a> <a href="#fnref:r-perform-rprof-profr" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:r-perform-lineprof">
      <p><a href="http://blog.fens.me/r-perform-lineprof/">R语言性能可视化lineprof</a> <a href="#fnref:r-perform-lineprof" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:open-blas-r">
      <p><a href="http://www.bjt.name/2013/06/open-blas-r/">用 OpenBLAS 加速 R 的矩阵运算</a> <a href="#fnref:open-blas-r" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:parallel-computing-r">
      <p><a href="http://www.bjt.name/2012/07/parallel-computing-r/">并行化你的运算-初识parallel包</a> <a href="#fnref:parallel-computing-r" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:blog_61f013b80101rly8">
      <p><a href="http://blog.sina.com.cn/s/blog_61f013b80101rly8.html">R使用parallel包并行计算</a> <a href="#fnref:blog_61f013b80101rly8" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:havoc">
      <p>Some precautions are taken on Mac OS X: for example the event loops for R.app and the quartz device are inhibited in the child. This information is available at C level in the Rboolean variable R_isForkedChild. <a href="#fnref:havoc" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:r-cache-memoise">
      <p><a href="http://blog.fens.me/r-cache-memoise/">R语言本地缓存memoise</a> <a href="#fnref:r-cache-memoise" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:speed-up-R">
      <p><a href="http://meroa.com/speed-up-R/">简单加速R</a> <a href="#fnref:speed-up-R" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:r-import-tips">
      <p><a href="http://meroa.com/r-import-tips/">R数据读取的几点tips</a> <a href="#fnref:r-import-tips" class="reversefootnote">&#8617;</a> <a href="#fnref:r-import-tips:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:UtSmVsbMyPb4FQT3">
      <p><a href="http://mr-ping.com/post/UtSmVsbMyPb4FQT3">R语言读取数据-性能优化</a> <a href="#fnref:UtSmVsbMyPb4FQT3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

</section>
<section align="left">
<p></p>
<hr>
  <p><img/ src="/assets/images/alipay2me.png" alt="打赏作者" style="height: 160px"></p>
  <p></p>
<hr>
  <ul>
    
    <li class="pageNav">2017-06-22 &raquo; <a href="/2017/06/a-byte-of-ct-uav">A Bite of CT-UAV</a></li>
    
    <li class="pageNav">2016-10-24 &raquo; <a href="/2016/10/nnml-bp-learning">NNML（03）：BP 学习</a></li>
    
    <li class="pageNav">2016-10-16 &raquo; <a href="/2016/10/nnml-perceptron-learning">NNML（02）：感知器学习</a></li>
    
    <li class="pageNav">2016-10-09 &raquo; <a href="/2016/10/s13000-model">鲁棒及自适应控制（2）：模型</a></li>
    
    <li class="pageNav">2016-10-09 &raquo; <a href="/2016/10/nnml_introduction">NNML（01）：引言</a></li>
    
    <li class="pageNav">2016-09-24 &raquo; <a href="/2016/09/feasibility-about-home-camera-in-power-syetem-monitoring">家用监控设备用于电网的可行性分析</a></li>
    
    <li class="pageNav">2016-09-19 &raquo; <a href="/2016/09/feasibility-about-uav-in-cable-tunnel">无人机电缆隧道巡检可行性调研报告</a></li>
    
    <li class="pageNav">2016-09-18 &raquo; <a href="/2016/09/s13000-Introduction">鲁棒及自适应控制（1）：概论</a></li>
    
  </ul>
<p></p>
<span>
  <a  href="/2015/04/r-packages" class="pageNav" style="float:left"   >上一篇：R包开发 </a>
  &nbsp;&nbsp;&nbsp;
  <a  href="/2015/05/arules" class="pageNav" style="float:right"   >下一篇：arules：频繁项集与关联规则的挖掘 </a>  
</span>
</section>
<div id="disqus_thread"></div>
<script>

/**
*  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
*  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/

var disqus_config = function () {
this.page.url = 'http://qianjiye.de/2015/04/speed-up-r';  // Replace PAGE_URL with your page's canonical URL variable
this.page.identifier = 'http://qianjiye.de/2015/04/speed-up-r'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
};

(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = 'https://jiyeqian.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

<!-- <script type="text/javascript"> -->
<!-- $(function(){ -->
<!--   $(document).keydown(function(e) { -->
<!--     var url = false; -->
<!--         if (e.which == 37 || e.which == 72) {  // Left arrow and H -->
<!--          -->
<!--         url = '/2015/04/r-packages'; -->
<!--          -->
<!--         } -->
<!--         else if (e.which == 39 || e.which == 76) {  // Right arrow and L -->
<!--          -->
<!--         <1!-- url = 'http://localhost:4000/2015/05/arules'; --1> -->
<!--         url = '/2015/05/arules'; -->
<!--          -->
<!--         } else if (e.which == 75) {  // K -->
<!--           url = '#'; -->
<!--         } else if (e.which == 74) { // J -->
<!--         url = '/2015/04/speed-up-r/#timeSpan'; -->
<!--         } -->
<!--         if (url) { -->
<!--             window.location = url; -->
<!--         } -->
<!--   }); -->
<!-- }) -->
<!-- </script> -->

        </article>
      </div>

    <footer>
        <p><small>
            Powered by <a href="http://jekyllrb.com" target="_blank">Jekyll</a> | Copyright 2014 - 2018 by <a href="/about/">Jiye Qian</a> | <span class="label label-info" id="timeSpan"></span></small></p>
    </footer>

    </div>
  </body>
</html>
